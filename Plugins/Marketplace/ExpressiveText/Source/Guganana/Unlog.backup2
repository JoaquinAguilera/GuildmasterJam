// Copyright 2022 Guganana. All Rights Reserved.
#pragma once

#include <CoreMinimal.h>
#include <Internationalization/TextFormatter.h>
#include <Developer/MessageLog/Public/MessageLogModule.h>
#include <Developer/MessageLog/Public/IMessageLogListing.h>
#include <DrawDebugHelpers.h>
#include <Modules/ModuleManager.h>
#include <VisualLogger.h>


#define UNLOG_VERSION TEXT("1.0")


// TODO check for shipping since drawdebug isn't available on shipping

#if WITH_EDITOR
class FTelemetryDispatcher
{

public:
    FTelemetryDispatcher()
    {
        const auto Prod = TEXT("Unlog");
        const auto AppId = Id::Get().ToString();
        const auto SHA = TEXT("None");
        const auto Date = FDateTime(2023, 8, 20).ToIso8601();
        const auto UEVersion = FEngineVersion::Current().ToString();

        // Running request as a console command cuts direct dependencies to the
        // http module which would make Unlog harder to include since it's a header only lib
        const FString Cmd = FString::Format(
            TEXT(
                "http TEST \"1\" "
                "\"https://api.guganana.com/api/usage?data="
                "%7B"
                "%22pluginName%22%3A%22{0}%22"
                "%2C%22appId%22%3A%22{1}%22"
                "%2C%22versionFriendly%22%3A%22{2}%22"
                "%2C%22versionSHA%22%3A%22{3}%22"
                "%2C%22versionDate%22%3A%22{4}%22"
                "%2C%22unrealVersion%22%3A%22{5}%22"
                "%7D\""
            ),
            { Prod, AppId, UNLOG_VERSION, SHA, Date, UEVersion }
        );

        const auto RunCmd = [Cmd] {
            GEngine->Exec(nullptr, *Cmd);
        };

        if (!GEngine || !GEngine->IsInitialized())
        {
            FCoreDelegates::OnPostEngineInit.AddLambda(RunCmd);
        }
        else
        {
            RunCmd();
        }
    }

private:
    struct Id
    {
        static FGuid Get()
        {
            static FGuid Id = FGuid();

            if (Id == FGuid())
            {
                if (!TryReadFromFile(Id))
                {
                    Id = FGuid::NewGuid();
                    SaveGuid(Id);
                }
            }

            return Id;
        }

        static FString GetIdFilePath()
        {
            return FPaths::Combine(FPaths::EngineVersionAgnosticUserDir(), TEXT("Unlog"), TEXT("Id"));
        }

        static bool TryReadFromFile(FGuid& OutGuid)
        {
            FString FileData;
            if (FFileHelper::LoadFileToString(FileData, *GetIdFilePath()))
            {
                FGuid Result;
                if (FGuid::Parse(FileData, Result))
                {
                    OutGuid = Result;
                    return true;
                }
            }

            return false;
        }

        static void SaveGuid(const FGuid& Guid)
        {
            FFileHelper::SaveStringToFile(Guid.ToString(), *GetIdFilePath());
        }
    };
};
#endif // WITH_EDITOR

// MACRO EXPANDS


template<bool InIsPrintfFormat>
struct TFormatOptions
{
    static constexpr bool IsPrintfFormat = InIsPrintfFormat;
};

template< typename InFormatOptions, typename InCategoryPicker, typename InSinkOptions >
struct TStaticConfiguration
{
    using FormatOptions = InFormatOptions;
    using CategoryPicker = InCategoryPicker;
    using SinkOptions = InSinkOptions;
};

#define UNLOG_DECLARE_CATEGORY_LOG_FUNCTION_CONDITIONALS( CategoryPicker, SinkOptions, FunctionName, VerbosityName, IsPrintf ) \
    template<typename FMT, typename... ArgTypes> \
    FORCEINLINE static void FunctionName(const FMT& Format, ArgTypes... Args)\
    {\
        using Configuration = TStaticConfiguration< TFormatOptions<IsPrintf>, CategoryPicker, SinkOptions >;\
        Unlogger::Get().UnlogPrivateImpl< Configuration >(Format, ELogVerbosity::VerbosityName, Args...);\
    }\
    template<typename FMT, typename... ArgTypes>\
    FORCEINLINE static void FunctionName(const bool Condition, const FMT& Format, ArgTypes... Args)\
    {\
        if(Condition)\
        {\
            using Configuration = TStaticConfiguration< TFormatOptions<IsPrintf>, CategoryPicker, SinkOptions >;\
            Unlogger::Get().UnlogPrivateImpl< Configuration >(Format, ELogVerbosity::VerbosityName, Args...);\
        }\
    }\
    template<typename Functor, typename FMT, typename... ArgTypes>\
    FORCEINLINE static void FunctionName(const Functor LambdaCondition, const FMT& Format, ArgTypes... Args)\
    {\
        FunctionName( LambdaCondition(), Format, Args... );\
    }

#define UNLOG_DECLARE_CATEGORY_LOG_FUNCTION( CategoryPicker, SinkOptions, FunctionName, VerbosityName )\
    UNLOG_DECLARE_CATEGORY_LOG_FUNCTION_CONDITIONALS( CategoryPicker, SinkOptions, FunctionName, VerbosityName, false )\
    UNLOG_DECLARE_CATEGORY_LOG_FUNCTION_CONDITIONALS( CategoryPicker, SinkOptions, FunctionName##f, VerbosityName, true )



// CATEGORY
class UnlogCategoryBase
{
private:
    FName CategoryName;
    ELogVerbosity::Type Verbosity;

public:

    UnlogCategoryBase(const FName& InName, ELogVerbosity::Type InVerbosity)
        : CategoryName(InName)
        , Verbosity(InVerbosity)
    {}

    const FName& GetName() const
    {
        return CategoryName;
    }

    ELogVerbosity::Type GetVerbosity() const
    {
        return Verbosity;
    }
};

template<typename TCategory>
class UnlogCategoryCRTP : public UnlogCategoryBase
{

public:
    using UnlogCategoryBase::UnlogCategoryBase;

    static TCategory& Static()
    {
        static TCategory Type = TCategory::Construct();
        return Type;
    }

    static UnlogCategoryBase* Get()
    {
        return &Static();
    }

    UNLOG_DECLARE_CATEGORY_LOG_FUNCTION(TSpecificCategory<TCategory>, Target::Default, Log, Log)
    UNLOG_DECLARE_CATEGORY_LOG_FUNCTION(TSpecificCategory<TCategory>, Target::Default, Warn, Warning)
    UNLOG_DECLARE_CATEGORY_LOG_FUNCTION(TSpecificCategory<TCategory>, Target::Default, Error, Error)
    UNLOG_DECLARE_CATEGORY_LOG_FUNCTION(TSpecificCategory<TCategory>, Target::Default, Display, Display)
    UNLOG_DECLARE_CATEGORY_LOG_FUNCTION(TSpecificCategory<TCategory>, Target::Default, Verbose, Verbose)
    UNLOG_DECLARE_CATEGORY_LOG_FUNCTION(TSpecificCategory<TCategory>, Target::Default, VeryVerbose, VeryVerbose)
};

#define UNLOG_DEFAULT_SETTINGS( SettingsName ) \
const int32 SetGlobalUnlogSettings< SettingsName >::Initializer = [] { Unlogger::Get().ApplySettings< SettingsName >();  return 0; }();

template< typename TCategory >
struct FUnlogScopedCategory 
{
    FUnlogScopedCategory()
    {
        Unlogger::Get().PushCategory( TCategory::Static() );
    }

    ~FUnlogScopedCategory()
    {
        Unlogger::Get().PopCategory();
    }
};

// Creates a new Unlog category.
// Can be used anywhere (headers, inside .cpp files, inside classes or functions)
// Generates a unique class for this category and can be shared with other files if put in a common header
#define UNLOG_CATEGORY(CategoryName)  \
class CategoryName : public UnlogCategoryCRTP< CategoryName > \
{\
protected:\
    using UnlogCategoryCRTP<CategoryName>::UnlogCategoryCRTP; \
    static CategoryName Construct()\
    {\
        return CategoryName( TEXT( #CategoryName ), ELogVerbosity::Log );\
    }\
friend class UnlogCategoryCRTP< CategoryName >;\
};

#define UNLOG_CATEGORY_PUSH( CategoryName ) \
    FUnlogScopedCategory<CategoryName> ScopedCategory_##CategoryName = FUnlogScopedCategory<CategoryName>();

#define UNLOG_CATEGORY_SCOPED(CategoryName) \
    UNLOG_CATEGORY(CategoryName) \
    UNLOG_CATEGORY_PUSH(CategoryName)


// Create the default category used by Unlog
UNLOG_CATEGORY(LogGeneral)

//CONTEXT

template <typename ActualType>
class UnlogContextBase
{
private:
    FName ContextName;
    uint32 Counter;

public:

    UnlogContextBase(const FName& InName)
        : ContextName(InName)
        , Counter(0u)
    {}

    static ActualType& Static()
    {
        static ActualType Type = ActualType::Construct();
        return Type;
    }

    const FName& GetName() const
    {
        return ContextName;
    }

    void IncrementCounter()
    {
        Counter++;
    }

    void DecrementCounter()
    {
        check(Counter > 0u);
        Counter--;
    }

    bool IsActive() const
    {
        return Counter > 0u;
    }

    template< typename Functor >
    static void WhenActive(Functor Func)
    {
        if (ActualType::Static().IsActive())
        {
            Func();
        }
    }
};

template <typename ActualType>
class UnloggerScopedContext
{
private:
    bool Value;
public:
    UnloggerScopedContext(bool InValue)
        : Value(InValue)
    {
        if (Value)
        {
            ActualType::Static().IncrementCounter();
        }
    }

    ~UnloggerScopedContext()
    {
        if (Value)
        {
            ActualType::Static().DecrementCounter();
        }
    }

};


#define uncontext(ContextName) \
class ContextName : public UnlogContextBase< ContextName > \
{\
public:\
    using UnlogContextBase< ContextName >::UnlogContextBase; \
    static ContextName Construct()\
    {\
        return ContextName( TEXT( #ContextName ) );\
    }\
};

#define scopedcontext(ContextName, ContextValue) \
UnloggerScopedContext< ContextName > ScopedContext_##ContextName( ContextValue );


template< typename TContext, typename Functor >
void WhenInContext(Functor Func)
{
    if (TContext::Static().IsActive())
    {
        Func();
    }
}

// SINKS
class UnlogSinkBase
{
public:
    virtual ~UnlogSinkBase() {}
    virtual void ProcessLog(const FName& Category, ELogVerbosity::Type Verbosity, const FString& Message) = 0;
};

struct UnlogSettingsBase
{
public:

    UnlogSettingsBase()
        : Sinks()
        , DefaultCategory()
    {
    }

    template< typename TSink>
    TSharedRef<TSink> AddSink()
    {
        auto Sink = TSharedRef<UnlogSinkBase>(MakeShareable(new TSink()));
        Sinks.Add(Sink);
        return StaticCastSharedRef<TSink>(Sink);
    }

    const TArray<TSharedRef<UnlogSinkBase>>& GetSinks()
    {
        return Sinks;
    }

    template< typename TCategory >
    void SetDefaultCategory()
    {
        DefaultCategory = &TCategory::Static();
    }

    UnlogCategoryBase& GetDefaultCategory()
    {
        return DefaultCategory ? *DefaultCategory : LogGeneral::Static();
    }

private:
    TArray<TSharedRef<UnlogSinkBase>> Sinks;
    UnlogCategoryBase* DefaultCategory;
};

template< typename ConcreteSettings >
struct SettingsCRTP : public UnlogSettingsBase
{
public:
    using UnlogSettingsBase::UnlogSettingsBase;

    static ConcreteSettings MakeSettings()
    {
        ConcreteSettings Settings;
        Settings.PopulateSettings();
        return Settings;
    }

    static ConcreteSettings& Static()
    {
        static ConcreteSettings Type = MakeSettings();
        return Type;
    }
};

struct UnlogDefaultSettings : public SettingsCRTP<UnlogDefaultSettings>
{
    using SettingsCRTP<UnlogDefaultSettings>::SettingsCRTP;
public:
    void PopulateSettings()
    {
        SetDefaultCategory<LogGeneral>();
    }
};

template< typename TUnlogSettings >
struct SetGlobalUnlogSettings
{
    const static int32 Initializer;
};


class Unlogger
{
private:
    // Settings should never be destroyed since they are statically created
    UnlogSettingsBase* Settings;

    // Pushed categories temporarily override the default category, usually during a certain scope
    TArray<UnlogCategoryBase*> PushedCategories;

public:

    static Unlogger& Get()
    {
        static Unlogger Logger = CreateLogger();
        return Logger;
    }

    static Unlogger CreateLogger()
    {
        // Start with default settings
        Unlogger Logger;
        Logger.ApplySettingsInternal<UnlogDefaultSettings>(); 

#if WITH_EDITOR
        static const FTelemetryDispatcher TelemetryDispatcher = FTelemetryDispatcher();
#endif
        return Logger;
    }

    template< typename TSettings > 
    static void ApplySettings()
    {
        Unlogger::Get().ApplySettingsInternal<TSettings>();
    }

    template< typename TSettings >
    void ApplySettingsInternal()
    {
        Settings = &TSettings::Static();
    }

    void PushCategory(UnlogCategoryBase& Category)
    {
        PushedCategories.Push(&Category);
    }

    void PopCategory()
    {
        check(PushedCategories.Num() > 0);
        PushedCategories.Pop();
    }

    FORCEINLINE const TCHAR* ResolveString(const TCHAR* Format)
    {
        return Format;
    }

    FORCEINLINE const TCHAR* ResolveString(const char* Format)
    {
        return UTF8_TO_TCHAR(Format);
    }


    template<typename CategoryPicker>
    FORCEINLINE const UnlogCategoryBase& PickCategory()
    {
        if (UnlogCategoryBase* Category = CategoryPicker::Get())
        {
            return *Category;
        }

        return PushedCategories.Num() > 0 ? *PushedCategories.Last() : Settings->GetDefaultCategory();
    }

    // Use ordered arguments format
    template< 
        typename FormatOptions,
        typename FMT,
        typename... ArgTypes >
    FORCEINLINE typename TEnableIf<!FormatOptions::IsPrintfFormat, FString>::Type  ProcessFormatString(const FMT& Format, ArgTypes... Args)
    {
        // TO DO - use FStringFormatArg
        static_assert(TAnd<TIsConstructible<FFormatArgumentValue, ArgTypes>...>::Value, "Invalid argument type passed to UnlogPrivateImpl");
        FString ResolvedString(ResolveString(Format));
        return FTextFormatter::FormatStr(FTextFormat::FromString(ResolvedString), FFormatOrderedArguments({ Args... }), false, false);
    }

    // Use Printf format
    template<
        typename FormatOptions,
        typename FMT,
        typename... ArgTypes >
    FORCEINLINE typename TEnableIf<FormatOptions::IsPrintfFormat, FString>::Type ProcessFormatString(const FMT& Format, ArgTypes... Args)
    {
        static_assert(!TIsArrayOrRefOfType<FMT, char>::Value, "Unlog's printf style functions only support text wrapped by TEXT()");
        FString Result = FString::Printf(Format, Args...);
        return Result;
    }

    template<typename StaticConfiguration, typename FMT, typename... ArgTypes>
    void UnlogPrivateImpl(const FMT& Format, ELogVerbosity::Type Verbosity, ArgTypes... Args)
    {
        check(Settings);

        const auto& Category = PickCategory<StaticConfiguration::CategoryPicker>();
        FName CategoryName = Category.GetName();

        if (Verbosity <= Category.GetVerbosity() && Verbosity != ELogVerbosity::NoLogging )
        {
            FString Result = ProcessFormatString<StaticConfiguration::FormatOptions>(Format, Args...);
            FMsg::Logf(nullptr, 0, CategoryName, Verbosity, TEXT("%s"), *Result);
        
            // Runtime Sinks
            for ( auto& Sink : Settings->GetSinks() )
            {
                Sink->ProcessLog(CategoryName, Verbosity, Result);
            }

            // Execute all static sinks
            StaticConfiguration::SinkOptions::Call(Category, Verbosity, Result);
        }
    }
};


// NEEDS typename after every = for linux

#define UNLOG_DECLARE_TEMPLATE_FOR_FORMAT( FunctionName, VerbosityName, IsPrintf ) \
template<typename UnlogCategoryType, typename FMT, typename... ArgTypes> \
FORCEINLINE void FunctionName(const FMT& Format, ArgTypes... Args)\
{\
    using Configuration = TStaticConfiguration< TFormatOptions<IsPrintf>, TSpecificCategory<UnlogCategoryType>, Target::Default >;\
    Unlogger::Get().UnlogPrivateImpl< Configuration >(Format, ELogVerbosity::VerbosityName, Args...);\
}\
template<typename FMT, typename... ArgTypes>\
FORCEINLINE void FunctionName(const FMT& Format, ArgTypes... Args)\
{\
    using Configuration = TStaticConfiguration< TFormatOptions<IsPrintf>, TDeriveCategory, Target::Default >;\
    Unlogger::Get().UnlogPrivateImpl< Configuration >(Format, ELogVerbosity::VerbosityName, Args...);\
}

#define UNLOG_DECLARE_GLOBAL_TEMPLATES( FunctionName, VerbosityName ) \
UNLOG_DECLARE_TEMPLATE_FOR_FORMAT( FunctionName, VerbosityName, false ) \
UNLOG_DECLARE_TEMPLATE_FOR_FORMAT( FunctionName##f, VerbosityName, true) 

UNLOG_DECLARE_GLOBAL_TEMPLATES(UnlogLog, Log)
UNLOG_DECLARE_GLOBAL_TEMPLATES(UnlogWarn, Warning)
UNLOG_DECLARE_GLOBAL_TEMPLATES(UnlogError, Error)
UNLOG_DECLARE_GLOBAL_TEMPLATES(UnlogDisplay, Display)
UNLOG_DECLARE_GLOBAL_TEMPLATES(UnlogVerbose, Verbose)
UNLOG_DECLARE_GLOBAL_TEMPLATES(UnlogVeryVerbose, VeryVerbose)



// static sinks




namespace Target
{
    struct MessageLog
    {
        static TSharedRef<IMessageLogListing> GetLogListing(FMessageLogModule& MessageLogModule, const FName& CategoryName)
        {
            auto Listing = MessageLogModule.GetLogListing(CategoryName);
            Listing->SetLabel(FText::FromString(CategoryName.ToString()));
            return Listing;
        }

        static EMessageSeverity::Type VerbosityToSeverity(ELogVerbosity::Type Verbosity)
        {
            switch (Verbosity)
            {
            case ELogVerbosity::Error:
                return EMessageSeverity::Error;
            case ELogVerbosity::Warning:
                return EMessageSeverity::Warning;
            }
            return EMessageSeverity::Info;
        }

        static void Call(const UnlogCategoryBase& Category, ELogVerbosity::Type Verbosity, const FString& Message)
        {
            FMessageLogModule& MessageLogModule = FModuleManager::LoadModuleChecked<FMessageLogModule>("MessageLog");

            auto LogListing = GetLogListing(MessageLogModule, Category.GetName());
            LogListing->AddMessage(
                FTokenizedMessage::Create(
                    VerbosityToSeverity(Verbosity),
                    FText::FromString(Message)
                )
            );

            if (Verbosity == ELogVerbosity::Error)
            {
                MessageLogModule.OpenMessageLog(Category.GetName());
            }
        }
    };


    template< int TimeOnScreen, const FColor& InColor >
    struct TGameScreenWithArgs
    {
        static void Call(const UnlogCategoryBase& Category, ELogVerbosity::Type Verbosity, const FString& Message)
        {
            GEngine->AddOnScreenDebugMessage(INDEX_NONE, TimeOnScreen, InColor, Message);
        }
    };

    struct NoTarget
    {
        static void Call(const UnlogCategoryBase& Category, ELogVerbosity::Type Verbosity, const FString& Message)
        {
        }
    };




    using GameScreen = TGameScreenWithArgs<3, FColor::Cyan>;

    using Default = NoTarget;

    template< typename... TSinks >
    struct TMulti
    {
        static void Call(const UnlogCategoryBase& Category, ELogVerbosity::Type Verbosity, const FString& Message)
        {
            auto Ignore = { (TSinks::Call(Category, Verbosity, Message),0)... };
        }
    };

    
}





//template<>
//struct TMultiSink<>
//{
//    static void Call(const UnlogCategoryBase& Category, ELogVerbosity::Type Verbosity, const FString& Message)
//    {
//    }
//};
//




template< typename CategoryPicker, typename SinkOptions >
class MakeUnlogger
{
public:
    UNLOG_DECLARE_CATEGORY_LOG_FUNCTION(CategoryPicker, SinkOptions, Log, Log)
    UNLOG_DECLARE_CATEGORY_LOG_FUNCTION(CategoryPicker, SinkOptions, Warn, Warning)
    UNLOG_DECLARE_CATEGORY_LOG_FUNCTION(CategoryPicker, SinkOptions, Error, Error)
    UNLOG_DECLARE_CATEGORY_LOG_FUNCTION(CategoryPicker, SinkOptions, Display, Display)
    UNLOG_DECLARE_CATEGORY_LOG_FUNCTION(CategoryPicker, SinkOptions, Verbose, Verbose)
    UNLOG_DECLARE_CATEGORY_LOG_FUNCTION(CategoryPicker, SinkOptions, VeryVerbose, VeryVerbose)
};


template< typename TCategory >
struct TSpecificCategory
{
    static UnlogCategoryBase* Get()
    {
        return &TCategory::Static();
    }
};

struct TDeriveCategory
{
    static UnlogCategoryBase* Get()
    {
        return nullptr;
    }
};

namespace Viz
{
    FORCEINLINE void DrawLabel( UWorld* World, const FVector& Position, const FString& Label, const FString& Value )
    {
        auto CategoryName = LogGeneral::Static().GetName();

        const FString& Message = FString::Format(
            TEXT("| Category: {0}\n")
            TEXT("| Value: {1}\n")
            TEXT("| {2}"),
            { CategoryName.ToString(), Value, Label }
        );

        DrawDebugString(World, Position + FVector(0.f, 0.f, 0.f), Message, nullptr, FColor::White, -1.000000, false, 1.f);
    }

    struct Location 
    {
        FORCEINLINE static void Display(UObject* Owner, const FVector& Position, const FColor& Color = FColor::Red, float Radius = 10.f)
        {
            DrawDebugSphere(Owner->GetWorld(), Position, Radius, 12, Color, false, -1.f, SDPG_World, 2.f);
            DrawLabel(Owner->GetWorld(), Position, TEXT("Test position"), Position.ToString());
            FVisualLogger::GeometryShapeLogf(Owner, "Test", ELogVerbosity::Log, Position, Radius, Color, TEXT("") );//, ##__VA_ARGS__)
        }
    };

    struct Direction
    {
        FORCEINLINE static void Display(UObject* Owner, const FVector& Start, const FVector& Direction, const FColor& Color = FColor::Cyan )
        {
            DrawDebugDirectionalArrow(Owner->GetWorld(), Start, Start + (Direction.GetSafeNormal() * 100.f), 10.f, Color, true, -1.f, SDPG_World, 2.f);
            DrawLabel(Owner->GetWorld(), Direction, TEXT("Test direction"), Direction.ToString());
            FVisualLogger::ArrowLogf(Owner, "Test", ELogVerbosity::Log, Start, Start + Direction, Color, TEXT(""));//, ##__VA_ARGS__)
        }
    };
};

template<typename InSinkOptions = Target::Default , typename InCategoryPicker = TDeriveCategory>
class TUnlog
{
public:
    using CategoryPicker = InCategoryPicker;
    using SinkOptions = InSinkOptions;

    template< typename... Sinks >
    using WithTarget = TUnlog< Target::TMulti<Sinks...>, InCategoryPicker >;

    template< typename InCategory >
    using WithCategory = TUnlog< InSinkOptions, InCategory>;

    UNLOG_DECLARE_CATEGORY_LOG_FUNCTION(CategoryPicker, SinkOptions, Log, Log)
    UNLOG_DECLARE_CATEGORY_LOG_FUNCTION(CategoryPicker, SinkOptions, Warn, Warning)
    UNLOG_DECLARE_CATEGORY_LOG_FUNCTION(CategoryPicker, SinkOptions, Error, Error)
    UNLOG_DECLARE_CATEGORY_LOG_FUNCTION(CategoryPicker, SinkOptions, Display, Display)
    UNLOG_DECLARE_CATEGORY_LOG_FUNCTION(CategoryPicker, SinkOptions, Verbose, Verbose)
    UNLOG_DECLARE_CATEGORY_LOG_FUNCTION(CategoryPicker, SinkOptions, VeryVerbose, VeryVerbose)

    template< typename TVisualizer, typename... TArgs>
    static void Debug( UObject* Owner, /*FName Name, */ TArgs... Args)
    {
        TVisualizer::Display(Owner, Args...);
    }

};

using Unlog = TUnlog<>;


// MACRO EXPANDS

template<typename MacroOptions, bool IsPrintfFormat, typename FMT, typename... TArgs>
FORCEINLINE void UnlogMacroExpand(ELogVerbosity::Type InVerbosity, const FMT& Format, TArgs... Args)
{
    using Configuration = TStaticConfiguration< 
        TFormatOptions<IsPrintfFormat>, 
        MacroOptions::CategoryOptions, 
        MacroOptions::SinkOptions 
    >;

    Unlogger::Get().UnlogPrivateImpl<Configuration>(Format, InVerbosity, Args...);
}

// MACROS

//
//
//template<typename TCategoryOptions, typename TSinkOptions, typename = void>
//struct TMacroOptionsInner;
//
//
//template< typename TCategory, typename TSinkOptions>
//struct TMacroOptionsInner<
//    TCategory,
//    TSinkOptions,
//    typename TEnableIf< TIsDerivedFrom<TCategory, UnlogCategoryBase>::IsDerived >::Type>
//{
//    using CategoryOptions = TSpecificCategory< TCategory >;
//    using SinkOptions = TMultiSink<TSinkOptions>;
//};
//
//template< typename TCategory>
//struct TMacroOptionsInner<
//    TCategory,
//    Target::Default,
//    typename TEnableIf< true >::Type >
//{
//    using CategoryOptions = TSpecificCategory< TCategory >;
//    using SinkOptions = Target::Default;
//};
//
//
//
//
//template<typename TSinkOptions>
//struct TMacroOptionsInner<
//    TDeriveCategory,
//    TSinkOptions,
//    typename TEnableIf< !TIsDerivedFrom<TSinkOptions, UnlogCategoryBase>::IsDerived >::Type
//>
//{
//    using CategoryOptions = TDeriveCategory;
//    using SinkOptions = TMultiSink<TSinkOptions>;
//};
//
//
//
//template<typename... TArgs>
//struct TMacroOptions
//{
//    using Inner = TMacroOptionsInner<TArgs...>;
//    using CategoryOptions = typename Inner::CategoryOptions;
//    using SinkOptions = typename Inner::SinkOptions;
//};
//
//
//template<typename... TArgs>
//struct TMacroOptions;
//
//template<typename TCategory, typename... TSinks>
//struct TMacroOptions<TCategory, TSinks...>
//{
//    using CategoryOptions = TSpecificCategory<TCategory>;
//    using SinkOptions = TMultiSink<TSinks...>;
//};
//
//
//
//template<typename TCategory >
//struct TMacroOptions<TCategory>
//{
//    using CategoryOptions = TSpecificCategory<TCategory>;
//    using SinkOptions = Target::Default;
//};
//
//template<>
//struct TMacroOptions<>
//{
//    using CategoryOptions = TDeriveCategory;
//    using SinkOptions = Target::Default;
//};


template<typename... TArgs>
struct TMacroOptions;

template<typename TCategory, typename... TSinks>
struct TMacroOptions<TCategory, TSinks...>
{
    using SinkOptions = Target::TMulti<TSinks...>;
    using CategoryOptions = TSpecificCategory<TCategory>;
};


template<typename InSinkOptions, typename InCategoryPicker >
struct TMacroOptions<TUnlog<InSinkOptions, InCategoryPicker>>
{
    using SinkOptions = InSinkOptions;
    using CategoryOptions = InCategoryPicker;
};

template<typename TCategory >
struct TMacroOptions<TCategory>
{
    using SinkOptions = Target::Default;
    using CategoryOptions = TSpecificCategory<TCategory>;
};

template<>
struct TMacroOptions<>
{
    using SinkOptions = Target::Default;
    using CategoryOptions = TDeriveCategory;
};


#define EXPAND( ... ) __VA_ARGS__


#define UNLOG( InMacroOptions, VerbosityName, Message, ... ) \
    UnlogMacroExpand< TMacroOptions< InMacroOptions >, false >( ELogVerbosity::VerbosityName, TEXT( Message ), ##__VA_ARGS__);

#define UNLOGF( CategoryName, VerbosityName, Message, ... ) \
    UnlogMacroExpand< TMacroOptions< InMacroOptions >, true >( ELogVerbosity::VerbosityName, TEXT( Message ), ##__VA_ARGS__);

#define UNCLOG( Condition, CategoryName, VerbosityName, Message, ... ) \
    if( Condition ) \
    {\
        UnlogMacroExpand< TMacroOptions< InMacroOptions >, false >( ELogVerbosity::VerbosityName, TEXT( Message ), ##__VA_ARGS__); \
    }
#define UNCLOGF( Condition, CategoryName, VerbosityName, Message, ... ) \
    if( Condition ) \
    {\
        UnlogMacroExpand< TMacroOptions< InMacroOptions >, true >( ELogVerbosity::VerbosityName, TEXT( Message ), ##__VA_ARGS__); \
    }



#define UNLOG_TARGET_IMPL( TargetName, ... ) \
class TargetName : public TUnlog<__VA_ARGS__> \
{};


#define UNLOG_TARGET( ... ) UNLOG_TARGET_IMPL( __VA_ARGS__ )

#define UNDEBUG( Type, ... ) Unlog::Debug< Viz::Type >( this, __VA_ARGS__ )